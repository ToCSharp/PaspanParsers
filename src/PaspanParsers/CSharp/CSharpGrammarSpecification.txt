C# GRAMMAR SPECIFICATION (BNF/EBNF)
Based on C# Language Specification (ECMA-334, ISO/IEC 23270)
========================================

This document provides a reference grammar for C# in BNF notation.

NOTATION:
  ::=         means "is defined as"
  |           means "or"
  [ ... ]     means optional (zero or one occurrence)
  { ... }     means zero or more occurrences
  < >         denotes a non-terminal symbol
  UPPERCASE   denotes keywords
  lowercase   denotes user-defined names

========================================
COMPILATION UNIT
========================================

<compilation unit> ::=
    [ <extern alias directives> ]
    [ <using directives> ]
    [ <global attributes> ]
    [ <namespace member declarations> ]

<extern alias directive> ::=
    EXTERN ALIAS <identifier> ';'

<extern alias directives> ::=
    <extern alias directive> { <extern alias directive> }

========================================
USING DIRECTIVES
========================================

<using directives> ::=
    <using directive> { <using directive> }

<using directive> ::=
    <using alias directive>
  | <using namespace directive>
  | <using static directive>

<using alias directive> ::=
    USING <identifier> '=' <namespace or type name> ';'

<using namespace directive> ::=
    USING <namespace name> ';'

<using static directive> ::=
    USING STATIC <type name> ';'

========================================
NAMESPACE DECLARATIONS
========================================

<namespace declaration> ::=
    NAMESPACE <qualified identifier> <namespace body> [ ';' ]

<qualified identifier> ::=
    <identifier> [ '.' <qualified identifier> ]

<namespace body> ::=
    '{' [ <extern alias directives> ] [ <using directives> ]
    [ <namespace member declarations> ] '}'

<namespace member declarations> ::=
    <namespace member declaration> { <namespace member declaration> }

<namespace member declaration> ::=
    <namespace declaration>
  | <type declaration>

========================================
TYPE DECLARATIONS
========================================

<type declaration> ::=
    <class declaration>
  | <struct declaration>
  | <interface declaration>
  | <enum declaration>
  | <delegate declaration>
  | <record declaration>

========================================
CLASS DECLARATION
========================================

<class declaration> ::=
    [ <attributes> ] [ <class modifiers> ] [ PARTIAL ] CLASS <identifier>
    [ <type parameter list> ]
    [ <class base> ]
    [ <type parameter constraints clauses> ]
    <class body> [ ';' ]

<class modifiers> ::=
    <class modifier> { <class modifier> }

<class modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | ABSTRACT | SEALED | STATIC | UNSAFE | FILE

<type parameter list> ::=
    '<' <type parameters> '>'

<type parameters> ::=
    [ <attributes> ] <type parameter> [ ',' <type parameters> ]

<type parameter> ::=
    <identifier>

<class base> ::=
    ':' <class type>
  | ':' <interface type list>
  | ':' <class type> ',' <interface type list>

<interface type list> ::=
    <interface type> [ ',' <interface type list> ]

<type parameter constraints clauses> ::=
    <type parameter constraints clause> { <type parameter constraints clause> }

<type parameter constraints clause> ::=
    WHERE <type parameter> ':' <type parameter constraints>

<type parameter constraints> ::=
    <primary constraint>
  | <secondary constraints>
  | <constructor constraint>
  | <primary constraint> ',' <secondary constraints>
  | <primary constraint> ',' <constructor constraint>
  | <secondary constraints> ',' <constructor constraint>
  | <primary constraint> ',' <secondary constraints> ',' <constructor constraint>

<primary constraint> ::=
    <class type>
  | CLASS [ '?' ]
  | STRUCT
  | UNMANAGED
  | NOTNULL

<secondary constraints> ::=
    <interface type> [ ',' <secondary constraints> ]

<constructor constraint> ::=
    NEW '(' ')'

<class body> ::=
    '{' [ <class member declarations> ] '}'

<class member declarations> ::=
    <class member declaration> { <class member declaration> }

<class member declaration> ::=
    <constant declaration>
  | <field declaration>
  | <method declaration>
  | <property declaration>
  | <event declaration>
  | <indexer declaration>
  | <operator declaration>
  | <constructor declaration>
  | <finalizer declaration>
  | <static constructor declaration>
  | <type declaration>

========================================
STRUCT DECLARATION
========================================

<struct declaration> ::=
    [ <attributes> ] [ <struct modifiers> ] [ PARTIAL ] STRUCT <identifier>
    [ <type parameter list> ]
    [ <struct interfaces> ]
    [ <type parameter constraints clauses> ]
    <struct body> [ ';' ]

<struct modifiers> ::=
    <struct modifier> { <struct modifier> }

<struct modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | READONLY | REF | UNSAFE | FILE

<struct interfaces> ::=
    ':' <interface type list>

<struct body> ::=
    '{' [ <struct member declarations> ] '}'

<struct member declarations> ::=
    <struct member declaration> { <struct member declaration> }

<struct member declaration> ::=
    <constant declaration>
  | <field declaration>
  | <method declaration>
  | <property declaration>
  | <event declaration>
  | <indexer declaration>
  | <operator declaration>
  | <constructor declaration>
  | <static constructor declaration>
  | <type declaration>

========================================
INTERFACE DECLARATION
========================================

<interface declaration> ::=
    [ <attributes> ] [ <interface modifiers> ] [ PARTIAL ] INTERFACE <identifier>
    [ <variant type parameter list> ]
    [ <interface base> ]
    [ <type parameter constraints clauses> ]
    <interface body> [ ';' ]

<interface modifiers> ::=
    <interface modifier> { <interface modifier> }

<interface modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | UNSAFE | FILE

<variant type parameter list> ::=
    '<' <variant type parameters> '>'

<variant type parameters> ::=
    [ <attributes> ] [ <variance annotation> ] <type parameter>
    [ ',' <variant type parameters> ]

<variance annotation> ::=
    IN | OUT

<interface base> ::=
    ':' <interface type list>

<interface body> ::=
    '{' [ <interface member declarations> ] '}'

<interface member declarations> ::=
    <interface member declaration> { <interface member declaration> }

<interface member declaration> ::=
    <interface method declaration>
  | <interface property declaration>
  | <interface event declaration>
  | <interface indexer declaration>

========================================
ENUM DECLARATION
========================================

<enum declaration> ::=
    [ <attributes> ] [ <enum modifiers> ] ENUM <identifier>
    [ <enum base> ] <enum body> [ ';' ]

<enum modifiers> ::=
    <enum modifier> { <enum modifier> }

<enum modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE

<enum base> ::=
    ':' <integral type>

<integral type> ::=
    SBYTE | BYTE | SHORT | USHORT | INT | UINT | LONG | ULONG

<enum body> ::=
    '{' [ <enum member declarations> ] '}'
  | '{' <enum member declarations> ',' '}'

<enum member declarations> ::=
    <enum member declaration> [ ',' <enum member declaration> ]

<enum member declaration> ::=
    [ <attributes> ] <identifier> [ '=' <constant expression> ]

========================================
DELEGATE DECLARATION
========================================

<delegate declaration> ::=
    [ <attributes> ] [ <delegate modifiers> ] DELEGATE <return type>
    <identifier> [ <variant type parameter list> ]
    '(' [ <formal parameter list> ] ')' [ <type parameter constraints clauses> ] ';'

<delegate modifiers> ::=
    <delegate modifier> { <delegate modifier> }

<delegate modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | UNSAFE

========================================
RECORD DECLARATION
========================================

<record declaration> ::=
    [ <attributes> ] [ <record modifiers> ] RECORD [ CLASS | STRUCT ] <identifier>
    [ <type parameter list> ]
    [ <parameter list> ]
    [ <record base> ]
    [ <type parameter constraints clauses> ]
    <record body> [ ';' ]

<record modifiers> ::=
    <record modifier> { <record modifier> }

<record modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | ABSTRACT | SEALED | STATIC | UNSAFE | FILE

<record base> ::=
    ':' <class type> [ <argument list> ]
  | ':' <interface type list>
  | ':' <class type> [ <argument list> ] ',' <interface type list>

<record body> ::=
    '{' [ <class member declarations> ] '}'
  | ';'

========================================
FIELD DECLARATION
========================================

<field declaration> ::=
    [ <attributes> ] [ <field modifiers> ] <type> <variable declarators> ';'

<field modifiers> ::=
    <field modifier> { <field modifier> }

<field modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | STATIC | READONLY | VOLATILE | UNSAFE | REQUIRED

<variable declarators> ::=
    <variable declarator> [ ',' <variable declarators> ]

<variable declarator> ::=
    <identifier> [ '=' <variable initializer> ]

<variable initializer> ::=
    <expression>
  | <array initializer>
  | <collection initializer>

========================================
METHOD DECLARATION
========================================

<method declaration> ::=
    <method header> <method body>

<method header> ::=
    [ <attributes> ] [ <method modifiers> ] [ PARTIAL ] <return type>
    <member name> [ <type parameter list> ] '(' [ <formal parameter list> ] ')'
    [ <type parameter constraints clauses> ]

<method modifiers> ::=
    <method modifier> { <method modifier> }

<method modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT
  | EXTERN | ASYNC | UNSAFE

<return type> ::=
    <type>
  | VOID
  | REF <type>
  | REF READONLY <type>

<member name> ::=
    <identifier>
  | <interface type> '.' <identifier>

<formal parameter list> ::=
    <fixed parameters>
  | <fixed parameters> ',' <parameter array>
  | <parameter array>

<fixed parameters> ::=
    <fixed parameter> [ ',' <fixed parameters> ]

<fixed parameter> ::=
    [ <attributes> ] [ <parameter modifier> ] <type> <identifier>
    [ '=' <default argument> ]

<parameter modifier> ::=
    THIS | REF | OUT | IN | PARAMS

<parameter array> ::=
    [ <attributes> ] PARAMS <array type> <identifier>

<method body> ::=
    <block>
  | '=>' <expression> ';'
  | ';'

========================================
PROPERTY DECLARATION
========================================

<property declaration> ::=
    [ <attributes> ] [ <property modifiers> ] <type> <member name>
    '{' <accessor declarations> '}'
  | [ <attributes> ] [ <property modifiers> ] <type> <member name>
    '=>' <expression> ';'

<property modifiers> ::=
    <property modifier> { <property modifier> }

<property modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT
  | EXTERN | UNSAFE | REQUIRED

<accessor declarations> ::=
    <get accessor declaration> [ <set accessor declaration> ]
  | <set accessor declaration> [ <get accessor declaration> ]
  | <get accessor declaration> [ <init accessor declaration> ]
  | <init accessor declaration> [ <get accessor declaration> ]

<get accessor declaration> ::=
    [ <attributes> ] [ <accessor modifier> ] GET <accessor body>

<set accessor declaration> ::=
    [ <attributes> ] [ <accessor modifier> ] SET <accessor body>

<init accessor declaration> ::=
    [ <attributes> ] [ <accessor modifier> ] INIT <accessor body>

<accessor modifier> ::=
    PROTECTED | INTERNAL | PRIVATE
  | PROTECTED INTERNAL | INTERNAL PROTECTED | PRIVATE PROTECTED

<accessor body> ::=
    <block>
  | '=>' <expression> ';'
  | ';'

========================================
EVENT DECLARATION
========================================

<event declaration> ::=
    [ <attributes> ] [ <event modifiers> ] EVENT <type> <variable declarators> ';'
  | [ <attributes> ] [ <event modifiers> ] EVENT <type> <member name>
    '{' <event accessor declarations> '}'

<event modifiers> ::=
    <event modifier> { <event modifier> }

<event modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT
  | EXTERN | UNSAFE

<event accessor declarations> ::=
    <add accessor declaration> <remove accessor declaration>
  | <remove accessor declaration> <add accessor declaration>

<add accessor declaration> ::=
    [ <attributes> ] ADD <block>

<remove accessor declaration> ::=
    [ <attributes> ] REMOVE <block>

========================================
INDEXER DECLARATION
========================================

<indexer declaration> ::=
    [ <attributes> ] [ <indexer modifiers> ] <type> THIS
    '[' <formal parameter list> ']' '{' <accessor declarations> '}'

<indexer modifiers> ::=
    <indexer modifier> { <indexer modifier> }

<indexer modifier> ::=
    NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE
  | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | UNSAFE

========================================
OPERATOR DECLARATION
========================================

<operator declaration> ::=
    [ <attributes> ] <operator modifiers> <operator declarator> <operator body>

<operator modifiers> ::=
    PUBLIC STATIC [ EXTERN | UNSAFE ]
  | STATIC PUBLIC [ EXTERN | UNSAFE ]
  | EXTERN PUBLIC STATIC
  | UNSAFE PUBLIC STATIC
  | (... other permutations ...)

<operator declarator> ::=
    <unary operator declarator>
  | <binary operator declarator>
  | <conversion operator declarator>

<unary operator declarator> ::=
    <type> OPERATOR <overloadable unary operator> '(' <type> <identifier> ')'

<overloadable unary operator> ::=
    '+' | '-' | '!' | '~' | '++' | '--' | TRUE | FALSE

<binary operator declarator> ::=
    <type> OPERATOR <overloadable binary operator>
    '(' <type> <identifier> ',' <type> <identifier> ')'

<overloadable binary operator> ::=
    '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^' | '<<' | '>>'
  | '>>>' | '==' | '!=' | '>' | '<' | '>=' | '<='

<conversion operator declarator> ::=
    IMPLICIT OPERATOR <type> '(' <type> <identifier> ')'
  | EXPLICIT OPERATOR <type> '(' <type> <identifier> ')'

<operator body> ::=
    <block>
  | '=>' <expression> ';'
  | ';'

========================================
CONSTRUCTOR DECLARATION
========================================

<constructor declaration> ::=
    [ <attributes> ] [ <constructor modifiers> ] <constructor declarator> <constructor body>

<constructor modifiers> ::=
    <constructor modifier> { <constructor modifier> }

<constructor modifier> ::=
    PUBLIC | PROTECTED | INTERNAL | PRIVATE | EXTERN | UNSAFE

<constructor declarator> ::=
    <identifier> '(' [ <formal parameter list> ] ')' [ <constructor initializer> ]

<constructor initializer> ::=
    ':' BASE '(' [ <argument list> ] ')'
  | ':' THIS '(' [ <argument list> ] ')'

<constructor body> ::=
    <block>
  | '=>' <expression> ';'
  | ';'

<static constructor declaration> ::=
    [ <attributes> ] <static constructor modifiers> <identifier> '(' ')' <static constructor body>

<static constructor modifiers> ::=
    STATIC [ EXTERN | UNSAFE ]
  | EXTERN STATIC [ UNSAFE ]
  | UNSAFE STATIC [ EXTERN ]

<static constructor body> ::=
    <block>
  | '=>' <expression> ';'
  | ';'

========================================
FINALIZER DECLARATION
========================================

<finalizer declaration> ::=
    [ <attributes> ] [ EXTERN | UNSAFE ] '~' <identifier> '(' ')' <finalizer body>

<finalizer body> ::=
    <block>
  | '=>' <expression> ';'
  | ';'

========================================
TYPES
========================================

<type> ::=
    <value type>
  | <reference type>
  | <type parameter>

<value type> ::=
    <struct type>
  | <enum type>

<struct type> ::=
    <type name>
  | <simple type>
  | <nullable value type>
  | <tuple type>

<simple type> ::=
    <numeric type>
  | BOOL

<numeric type> ::=
    <integral type>
  | <floating point type>
  | DECIMAL

<floating point type> ::=
    FLOAT | DOUBLE

<nullable value type> ::=
    <value type> '?'

<tuple type> ::=
    '(' <tuple type element> ',' <tuple type elements> ')'

<tuple type element> ::=
    <type> [ <identifier> ]

<tuple type elements> ::=
    <tuple type element> [ ',' <tuple type elements> ]

<reference type> ::=
    <class type>
  | <interface type>
  | <array type>
  | <delegate type>
  | OBJECT | STRING | DYNAMIC

<class type> ::=
    <type name>
  | <nullable reference type>

<nullable reference type> ::=
    <reference type> '?'

<interface type> ::=
    <type name>

<array type> ::=
    <non array type> <rank specifiers>

<non array type> ::=
    <type>

<rank specifiers> ::=
    <rank specifier> { <rank specifier> }

<rank specifier> ::=
    '[' [ <dim separators> ] ']'

<dim separators> ::=
    ',' { ',' }

<delegate type> ::=
    <type name>

<type name> ::=
    <namespace or type name>

<namespace or type name> ::=
    <identifier> [ <type argument list> ]
  | <namespace or type name> '.' <identifier> [ <type argument list> ]
  | <qualified alias member>

<type argument list> ::=
    '<' <type arguments> '>'

<type arguments> ::=
    <type argument> [ ',' <type arguments> ]

<type argument> ::=
    <type>

<qualified alias member> ::=
    <identifier> '::' <identifier> [ <type argument list> ]

========================================
STATEMENTS
========================================

<statement> ::=
    <labeled statement>
  | <declaration statement>
  | <embedded statement>

<embedded statement> ::=
    <block>
  | <empty statement>
  | <expression statement>
  | <selection statement>
  | <iteration statement>
  | <jump statement>
  | <try statement>
  | <checked statement>
  | <unchecked statement>
  | <lock statement>
  | <using statement>
  | <yield statement>
  | <await statement>

<block> ::=
    '{' [ <statement list> ] '}'

<statement list> ::=
    <statement> { <statement> }

<empty statement> ::=
    ';'

========================================
DECLARATION STATEMENT
========================================

<declaration statement> ::=
    <local variable declaration> ';'
  | <local constant declaration> ';'
  | <local function declaration>

<local variable declaration> ::=
    [ USING ] <local variable type> <local variable declarators>
  | REF [ READONLY ] <local variable type> <local variable declarators>

<local variable type> ::=
    <type>
  | VAR

<local variable declarators> ::=
    <local variable declarator> [ ',' <local variable declarators> ]

<local variable declarator> ::=
    <identifier> [ '=' <local variable initializer> ]

<local variable initializer> ::=
    <expression>
  | <array initializer>

<local constant declaration> ::=
    CONST <type> <constant declarators>

<constant declarators> ::=
    <constant declarator> [ ',' <constant declarators> ]

<constant declarator> ::=
    <identifier> '=' <constant expression>

<local function declaration> ::=
    [ <local function modifiers> ] <return type> <identifier>
    [ <type parameter list> ] '(' [ <formal parameter list> ] ')'
    [ <type parameter constraints clauses> ] <local function body>

<local function modifiers> ::=
    STATIC | ASYNC | UNSAFE | STATIC ASYNC | ASYNC STATIC

<local function body> ::=
    <block>
  | '=>' <expression> ';'

========================================
EXPRESSION STATEMENT
========================================

<expression statement> ::=
    <statement expression> ';'

<statement expression> ::=
    <invocation expression>
  | <object creation expression>
  | <assignment>
  | <post increment expression>
  | <post decrement expression>
  | <pre increment expression>
  | <pre decrement expression>
  | <await expression>

========================================
SELECTION STATEMENTS
========================================

<selection statement> ::=
    <if statement>
  | <switch statement>

<if statement> ::=
    IF '(' <boolean expression> ')' <embedded statement>
    [ ELSE <embedded statement> ]

<switch statement> ::=
    SWITCH '(' <expression> ')' '{' [ <switch sections> ] '}'

<switch sections> ::=
    <switch section> { <switch section> }

<switch section> ::=
    <switch labels> <statement list>

<switch labels> ::=
    <switch label> { <switch label> }

<switch label> ::=
    CASE <pattern> [ <case guard> ] ':'
  | DEFAULT ':'

<case guard> ::=
    WHEN <expression>

========================================
ITERATION STATEMENTS
========================================

<iteration statement> ::=
    <while statement>
  | <do statement>
  | <for statement>
  | <foreach statement>

<while statement> ::=
    WHILE '(' <boolean expression> ')' <embedded statement>

<do statement> ::=
    DO <embedded statement> WHILE '(' <boolean expression> ')' ';'

<for statement> ::=
    FOR '(' [ <for initializer> ] ';' [ <for condition> ] ';'
    [ <for iterator> ] ')' <embedded statement>

<for initializer> ::=
    <local variable declaration>
  | <statement expression list>

<for condition> ::=
    <boolean expression>

<for iterator> ::=
    <statement expression list>

<statement expression list> ::=
    <statement expression> [ ',' <statement expression list> ]

<foreach statement> ::=
    [ AWAIT ] FOREACH '(' <local variable type> <identifier> IN <expression> ')'
    <embedded statement>

========================================
JUMP STATEMENTS
========================================

<jump statement> ::=
    <break statement>
  | <continue statement>
  | <goto statement>
  | <return statement>
  | <throw statement>

<break statement> ::=
    BREAK ';'

<continue statement> ::=
    CONTINUE ';'

<goto statement> ::=
    GOTO <identifier> ';'
  | GOTO CASE <constant expression> ';'
  | GOTO DEFAULT ';'

<return statement> ::=
    RETURN [ <expression> ] ';'

<throw statement> ::=
    THROW [ <expression> ] ';'

========================================
TRY STATEMENT
========================================

<try statement> ::=
    TRY <block> <catch clauses>
  | TRY <block> <finally clause>
  | TRY <block> <catch clauses> <finally clause>

<catch clauses> ::=
    <specific catch clauses>
  | <specific catch clauses> <general catch clause>
  | <general catch clause>

<specific catch clauses> ::=
    <specific catch clause> { <specific catch clause> }

<specific catch clause> ::=
    CATCH '(' <class type> [ <identifier> ] ')' [ <exception filter> ] <block>
  | CATCH [ <exception filter> ] <block>

<exception filter> ::=
    WHEN '(' <boolean expression> ')'

<general catch clause> ::=
    CATCH <block>

<finally clause> ::=
    FINALLY <block>

========================================
CHECKED/UNCHECKED STATEMENTS
========================================

<checked statement> ::=
    CHECKED <block>

<unchecked statement> ::=
    UNCHECKED <block>

========================================
LOCK STATEMENT
========================================

<lock statement> ::=
    LOCK '(' <expression> ')' <embedded statement>

========================================
USING STATEMENT
========================================

<using statement> ::=
    USING '(' <resource acquisition> ')' <embedded statement>
  | AWAIT USING '(' <resource acquisition> ')' <embedded statement>

<resource acquisition> ::=
    <local variable declaration>
  | <expression>

========================================
YIELD STATEMENT
========================================

<yield statement> ::=
    YIELD RETURN <expression> ';'
  | YIELD BREAK ';'

========================================
LABELED STATEMENT
========================================

<labeled statement> ::=
    <identifier> ':' <statement>

========================================
EXPRESSIONS
========================================

<expression> ::=
    <non assignment expression>
  | <assignment>

<non assignment expression> ::=
    <conditional expression>
  | <lambda expression>
  | <query expression>

<assignment> ::=
    <unary expression> <assignment operator> <expression>

<assignment operator> ::=
    '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='
  | '<<=' | '>>=' | '>>>=' | '??='

========================================
CONDITIONAL EXPRESSION
========================================

<conditional expression> ::=
    <null coalescing expression>
  | <null coalescing expression> '?' <expression> ':' <expression>

<null coalescing expression> ::=
    <conditional or expression>
  | <conditional or expression> '??' <null coalescing expression>

========================================
LOGICAL EXPRESSIONS
========================================

<conditional or expression> ::=
    <conditional and expression>
  | <conditional or expression> '||' <conditional and expression>

<conditional and expression> ::=
    <inclusive or expression>
  | <conditional and expression> '&&' <inclusive or expression>

<inclusive or expression> ::=
    <exclusive or expression>
  | <inclusive or expression> '|' <exclusive or expression>

<exclusive or expression> ::=
    <and expression>
  | <exclusive or expression> '^' <and expression>

<and expression> ::=
    <equality expression>
  | <and expression> '&' <equality expression>

========================================
EQUALITY AND RELATIONAL EXPRESSIONS
========================================

<equality expression> ::=
    <relational expression>
  | <equality expression> '==' <relational expression>
  | <equality expression> '!=' <relational expression>

<relational expression> ::=
    <shift expression>
  | <relational expression> '<' <shift expression>
  | <relational expression> '>' <shift expression>
  | <relational expression> '<=' <shift expression>
  | <relational expression> '>=' <shift expression>
  | <relational expression> IS <type>
  | <relational expression> IS <pattern>
  | <relational expression> AS <type>

========================================
SHIFT EXPRESSIONS
========================================

<shift expression> ::=
    <additive expression>
  | <shift expression> '<<' <additive expression>
  | <shift expression> '>>' <additive expression>
  | <shift expression> '>>>' <additive expression>

========================================
ARITHMETIC EXPRESSIONS
========================================

<additive expression> ::=
    <multiplicative expression>
  | <additive expression> '+' <multiplicative expression>
  | <additive expression> '-' <multiplicative expression>

<multiplicative expression> ::=
    <switch expression>
  | <multiplicative expression> '*' <switch expression>
  | <multiplicative expression> '/' <switch expression>
  | <multiplicative expression> '%' <switch expression>

========================================
SWITCH EXPRESSION
========================================

<switch expression> ::=
    <range expression> SWITCH '{' [ <switch expression arms> ] '}'
  | <range expression>

<switch expression arms> ::=
    <switch expression arm> [ ',' <switch expression arms> ]

<switch expression arm> ::=
    <pattern> [ <case guard> ] '=>' <expression>

========================================
RANGE EXPRESSION
========================================

<range expression> ::=
    <unary expression>
  | <unary expression> '..' <unary expression>
  | <unary expression> '..'
  | '..' <unary expression>
  | '..'

========================================
UNARY EXPRESSIONS
========================================

<unary expression> ::=
    <primary expression>
  | <cast expression>
  | '+' <unary expression>
  | '-' <unary expression>
  | '!' <unary expression>
  | '~' <unary expression>
  | '++' <unary expression>
  | '--' <unary expression>
  | <await expression>
  | '&' <unary expression>
  | '*' <unary expression>
  | '^' <unary expression>

<cast expression> ::=
    '(' <type> ')' <unary expression>

<await expression> ::=
    AWAIT <unary expression>

========================================
PRIMARY EXPRESSIONS
========================================

<primary expression> ::=
    <primary no array creation expression>
  | <array creation expression>

<primary no array creation expression> ::=
    <literal>
  | <interpolated string expression>
  | <simple name>
  | <parenthesized expression>
  | <tuple expression>
  | <member access>
  | <null conditional member access>
  | <invocation expression>
  | <element access>
  | <null conditional element access>
  | <this access>
  | <base access>
  | <post increment expression>
  | <post decrement expression>
  | <object creation expression>
  | <delegate creation expression>
  | <anonymous object creation expression>
  | <typeof expression>
  | <sizeof expression>
  | <checked expression>
  | <unchecked expression>
  | <default value expression>
  | <nameof expression>
  | <anonymous method expression>
  | <with expression>
  | <throw expression>

<literal> ::=
    <boolean literal>
  | <integer literal>
  | <real literal>
  | <character literal>
  | <string literal>
  | <null literal>

<boolean literal> ::=
    TRUE | FALSE

<null literal> ::=
    NULL

<simple name> ::=
    <identifier> [ <type argument list> ]

<parenthesized expression> ::=
    '(' <expression> ')'

<tuple expression> ::=
    '(' <tuple element> ',' <tuple elements> ')'

<tuple element> ::=
    [ <identifier> ':' ] <expression>

<tuple elements> ::=
    <tuple element> [ ',' <tuple elements> ]

<member access> ::=
    <primary expression> '.' <identifier> [ <type argument list> ]

<null conditional member access> ::=
    <primary expression> '?' '.' <identifier> [ <type argument list> ]

<invocation expression> ::=
    <primary expression> '(' [ <argument list> ] ')'

<argument list> ::=
    <argument> [ ',' <argument list> ]

<argument> ::=
    [ <argument name> ] <argument value>

<argument name> ::=
    <identifier> ':'

<argument value> ::=
    <expression>
  | REF <variable reference>
  | OUT <variable reference>
  | IN <variable reference>

<element access> ::=
    <primary expression> '[' <argument list> ']'

<null conditional element access> ::=
    <primary expression> '?' '[' <argument list> ']'

<this access> ::=
    THIS

<base access> ::=
    BASE '.' <identifier>
  | BASE '[' <argument list> ']'

<post increment expression> ::=
    <primary expression> '++'

<post decrement expression> ::=
    <primary expression> '--'

========================================
OBJECT CREATION
========================================

<object creation expression> ::=
    NEW <type> '(' [ <argument list> ] ')' [ <object or collection initializer> ]
  | NEW <type> <object or collection initializer>
  | NEW <tuple type> '(' [ <argument list> ] ')'

<object or collection initializer> ::=
    <object initializer>
  | <collection initializer>

<object initializer> ::=
    '{' [ <member initializer list> ] '}'

<member initializer list> ::=
    <member initializer> [ ',' <member initializer list> ]

<member initializer> ::=
    <identifier> '=' <initializer value>
  | '[' <argument list> ']' '=' <initializer value>

<initializer value> ::=
    <expression>
  | <object or collection initializer>

<collection initializer> ::=
    '{' <element initializer list> '}'

<element initializer list> ::=
    <element initializer> [ ',' <element initializer list> ]

<element initializer> ::=
    <non assignment expression>
  | '{' <expression list> '}'

<expression list> ::=
    <expression> [ ',' <expression list> ]

<array creation expression> ::=
    NEW <non array type> '[' <expression list> ']' [ <rank specifiers> ]
    [ <array initializer> ]
  | NEW <array type> <array initializer>
  | NEW <rank specifier> <array initializer>

<array initializer> ::=
    '{' [ <variable initializer list> ] '}'

<variable initializer list> ::=
    <variable initializer> [ ',' <variable initializer list> ]

<delegate creation expression> ::=
    NEW <delegate type> '(' <expression> ')'

<anonymous object creation expression> ::=
    NEW <anonymous object initializer>

<anonymous object initializer> ::=
    '{' [ <member declarator list> ] '}'

<member declarator list> ::=
    <member declarator> [ ',' <member declarator list> ]

<member declarator> ::=
    <simple name>
  | <member access>
  | <identifier> '=' <expression>

========================================
OTHER PRIMARY EXPRESSIONS
========================================

<typeof expression> ::=
    TYPEOF '(' <type> ')'
  | TYPEOF '(' <unbound type name> ')'
  | TYPEOF '(' VOID ')'

<unbound type name> ::=
    <identifier> <generic dimension specifier>
  | <identifier> '::' <identifier> <generic dimension specifier>
  | <unbound type name> '.' <identifier> <generic dimension specifier>

<generic dimension specifier> ::=
    '<' [ <commas> ] '>'

<commas> ::=
    ',' { ',' }

<sizeof expression> ::=
    SIZEOF '(' <type> ')'

<checked expression> ::=
    CHECKED '(' <expression> ')'

<unchecked expression> ::=
    UNCHECKED '(' <expression> ')'

<default value expression> ::=
    DEFAULT [ '(' <type> ')' ]

<nameof expression> ::=
    NAMEOF '(' <named entity> ')'

<named entity> ::=
    <simple name>
  | <named entity> '.' <identifier>

<with expression> ::=
    <primary expression> WITH '{' [ <member initializer list> ] '}'

<throw expression> ::=
    THROW <expression>

========================================
LAMBDA EXPRESSIONS
========================================

<lambda expression> ::=
    [ ASYNC ] <anonymous function signature> '=>' <anonymous function body>

<anonymous function signature> ::=
    <explicit anonymous function signature>
  | <implicit anonymous function signature>

<explicit anonymous function signature> ::=
    '(' [ <explicit anonymous function parameter list> ] ')'

<explicit anonymous function parameter list> ::=
    <explicit anonymous function parameter> [ ',' <explicit anonymous function parameter list> ]

<explicit anonymous function parameter> ::=
    [ <anonymous function parameter modifier> ] <type> <identifier>

<anonymous function parameter modifier> ::=
    REF | OUT | IN

<implicit anonymous function signature> ::=
    '(' <implicit anonymous function parameter list> ')'
  | <implicit anonymous function parameter>

<implicit anonymous function parameter list> ::=
    <implicit anonymous function parameter> [ ',' <implicit anonymous function parameter list> ]

<implicit anonymous function parameter> ::=
    <identifier>

<anonymous function body> ::=
    <expression>
  | <block>

<anonymous method expression> ::=
    [ ASYNC ] DELEGATE [ <explicit anonymous function signature> ] <block>

========================================
QUERY EXPRESSIONS (LINQ)
========================================

<query expression> ::=
    <from clause> <query body>

<from clause> ::=
    FROM [ <type> ] <identifier> IN <expression>

<query body> ::=
    <query body clauses> <select or group clause> [ <query continuation> ]

<query body clauses> ::=
    <query body clause> { <query body clause> }

<query body clause> ::=
    <from clause>
  | <let clause>
  | <where clause>
  | <join clause>
  | <orderby clause>

<let clause> ::=
    LET <identifier> '=' <expression>

<where clause> ::=
    WHERE <boolean expression>

<join clause> ::=
    JOIN [ <type> ] <identifier> IN <expression>
    ON <expression> EQUALS <expression> [ <join into clause> ]

<join into clause> ::=
    INTO <identifier>

<orderby clause> ::=
    ORDERBY <orderings>

<orderings> ::=
    <ordering> [ ',' <orderings> ]

<ordering> ::=
    <expression> [ ASCENDING | DESCENDING ]

<select or group clause> ::=
    <select clause>
  | <group clause>

<select clause> ::=
    SELECT <expression>

<group clause> ::=
    GROUP <expression> BY <expression>

<query continuation> ::=
    INTO <identifier> <query body>

========================================
PATTERNS
========================================

<pattern> ::=
    <declaration pattern>
  | <constant pattern>
  | <var pattern>
  | <positional pattern>
  | <property pattern>
  | <discard pattern>
  | <type pattern>
  | <relational pattern>
  | <logical pattern>
  | <list pattern>

<declaration pattern> ::=
    <type> <designation>

<type pattern> ::=
    <type>

<constant pattern> ::=
    <constant expression>

<var pattern> ::=
    VAR <designation>

<designation> ::=
    <simple designation>
  | <parenthesized designation>
  | <discard designation>

<simple designation> ::=
    <identifier>

<parenthesized designation> ::=
    '(' <designation list> ')'

<designation list> ::=
    <designation> [ ',' <designation list> ]

<discard designation> ::=
    '_'

<discard pattern> ::=
    '_'

<positional pattern> ::=
    <type> '(' [ <subpattern list> ] ')' [ <designation> ]

<subpattern list> ::=
    <subpattern> [ ',' <subpattern list> ]

<subpattern> ::=
    <pattern>
  | <identifier> ':' <pattern>

<property pattern> ::=
    <type> '{' [ <property subpattern list> ] '}' [ <designation> ]
  | '{' [ <property subpattern list> ] '}' [ <designation> ]

<property subpattern list> ::=
    <property subpattern> [ ',' <property subpattern list> ]

<property subpattern> ::=
    <identifier> ':' <pattern>

<relational pattern> ::=
    '<' <expression>
  | '<=' <expression>
  | '>' <expression>
  | '>=' <expression>

<logical pattern> ::=
    <pattern> AND <pattern>
  | <pattern> OR <pattern>
  | NOT <pattern>

<list pattern> ::=
    '[' [ <list pattern elements> ] ']'

<list pattern elements> ::=
    <pattern> [ ',' <list pattern elements> ]
  | '..'
  | <pattern> ',' '..'
  | '..' ',' <pattern>
  | <pattern> ',' '..' ',' <pattern>

========================================
ATTRIBUTES
========================================

<global attributes> ::=
    <global attribute section> { <global attribute section> }

<global attribute section> ::=
    '[' <global attribute target specifier> <attribute list> ']'
  | '[' <global attribute target specifier> <attribute list> ',' ']'

<global attribute target specifier> ::=
    <global attribute target> ':'

<global attribute target> ::=
    ASSEMBLY | MODULE

<attributes> ::=
    <attribute section> { <attribute section> }

<attribute section> ::=
    '[' [ <attribute target specifier> ] <attribute list> ']'
  | '[' [ <attribute target specifier> ] <attribute list> ',' ']'

<attribute target specifier> ::=
    <attribute target> ':'

<attribute target> ::=
    FIELD | EVENT | METHOD | PARAM | PROPERTY | RETURN | TYPE

<attribute list> ::=
    <attribute> [ ',' <attribute list> ]

<attribute> ::=
    <attribute name> [ <attribute arguments> ]

<attribute name> ::=
    <type name>

<attribute arguments> ::=
    '(' [ <positional argument list> ] ')'
  | '(' <positional argument list> ',' <named argument list> ')'
  | '(' <named argument list> ')'

<positional argument list> ::=
    <positional argument> [ ',' <positional argument list> ]

<positional argument> ::=
    <attribute argument expression>

<named argument list> ::=
    <named argument> [ ',' <named argument list> ]

<named argument> ::=
    <identifier> '=' <attribute argument expression>

<attribute argument expression> ::=
    <expression>

========================================
ADDITIONAL REFERENCES
========================================

For complete C# specification:
- ECMA-334: C# Language Specification (https://ecma-international.org/publications-and-standards/standards/ecma-334/)
- ISO/IEC 23270: Information technology — Programming languages — C#
- Microsoft C# Language Specification (https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/specifications/)

C# Language Features by Version:
- C# 1.0: Classes, structs, interfaces, events, properties, delegates, operators
- C# 2.0: Generics, partial types, anonymous methods, iterators, nullable types
- C# 3.0: Auto-properties, object initializers, anonymous types, extension methods, query expressions, lambda expressions
- C# 4.0: Dynamic binding, named/optional arguments, generic covariance/contravariance
- C# 5.0: Async/await, caller info attributes
- C# 6.0: Expression-bodied members, null-conditional operators, string interpolation, nameof
- C# 7.0-7.3: Tuples, pattern matching, local functions, ref returns, discards, out variables
- C# 8.0: Nullable reference types, async streams, ranges and indices, default interface methods, switch expressions
- C# 9.0: Records, init-only setters, top-level statements, pattern matching enhancements
- C# 10.0: Global using directives, file-scoped namespaces, record structs, improved lambda expressions
- C# 11.0: Raw string literals, list patterns, required members, file-local types
- C# 12.0: Primary constructors, collection expressions, inline arrays

Online Resources:
- C# Documentation: https://learn.microsoft.com/en-us/dotnet/csharp/
- C# Language Reference: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/
- Roslyn Source Code: https://github.com/dotnet/roslyn

========================================
END OF SPECIFICATION
========================================

